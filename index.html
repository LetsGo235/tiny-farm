<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mini Farm V1.5</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #11151c;
      color: #f1f1f1;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    #game-container {
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding: 16px;
      box-sizing: border-box;
      gap: 16px;
    }

    #game {
      border: 2px solid #3c445a;
      background: #000;
      image-rendering: pixelated;
    }

    #hud {
      width: 260px;
      font-size: 14px;
      line-height: 1.4;
    }

    #hud h1 {
      margin: 0 0 8px 0;
      font-size: 18px;
    }

    .section {
      margin-bottom: 12px;
      padding: 8px;
      background: #181e2a;
      border-radius: 6px;
      border: 1px solid #272f42;
    }

    #message-box {
      min-height: 40px;
      padding: 4px;
      background: #101521;
      border-radius: 4px;
      border: 1px solid #2a3246;
      font-size: 13px;
    }

    .inventory-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .inventory-list li {
      margin-bottom: 2px;
    }

    .controls-text {
      font-size: 12px;
      color: #c5cde0;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game"></canvas>

    <div id="hud">
      <h1>Mini Farm V1.5</h1>

      <div class="section">
        <strong>Area:</strong> <span id="area-name">Farm</span>
      </div>

      <div class="section">
        <strong>Controls</strong>
        <div class="controls-text">
          Move: WASD / Arrow keys<br />
          Action: Space (till / plant / harvest / talk to merchant)
        </div>
      </div>

      <div class="section">
        <strong>Message</strong>
        <div id="message-box"></div>
      </div>

      <div class="section">
        <strong>Inventory</strong>
        <div id="inventory"></div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      "use strict";

      // ====== CONSTANTS ======
      const TILE_SIZE = 32;
      const WORLD_WIDTH = 64;
      const WORLD_HEIGHT = 40;
      const VIEWPORT_WIDTH = 640;
      const VIEWPORT_HEIGHT = 360;

      const CROP_GROWTH_TIME = 12; // seconds to fully grown
      const CROP_STAGES = 3;       // visual stages before "ready"

      // Farm and town layout (in tile coordinates)
      const FARM_BOUNDS = { xMin: 4, xMax: 28, yMin: 8, yMax: 32 };
      const TOWN_BOUNDS = { xMin: 38, xMax: 60, yMin: 8, yMax: 32 };
      const PATH_Y = Math.floor((FARM_BOUNDS.yMin + FARM_BOUNDS.yMax) / 2);
      const TOWN_CENTER_X = Math.floor((TOWN_BOUNDS.xMin + TOWN_BOUNDS.xMax) / 2);
      const TOWN_CENTER_Y = PATH_Y;

      // ====== DOM & CANVAS ======
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const messageBox = document.getElementById("message-box");
      const inventoryDiv = document.getElementById("inventory");
      const areaNameSpan = document.getElementById("area-name");

      canvas.width = VIEWPORT_WIDTH;
      canvas.height = VIEWPORT_HEIGHT;
      ctx.imageSmoothingEnabled = false;

      // ====== INPUT ======
      const keys = {};
      window.addEventListener("keydown", (e) => {
        keys[e.code] = true;
        if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Space"].includes(e.code)) {
          e.preventDefault();
        }
      });
      window.addEventListener("keyup", (e) => {
        keys[e.code] = false;
      });

      // ====== WORLD SETUP ======
      const TileType = {
        FARM_GRASS: 0,
        TILLED: 1,
        PATH: 2,
        TOWN_GRASS: 3,
        TOWN_STONE: 4
      };

      const world = [];
      for (let y = 0; y < WORLD_HEIGHT; y++) {
        const row = [];
        for (let x = 0; x < WORLD_WIDTH; x++) {
          row.push({
            type: TileType.TOWN_GRASS, // default base
            crop: null                 // { age, stage }
          });
        }
        world.push(row);
      }

      // Farm area â€“ lush green
      for (let y = FARM_BOUNDS.yMin; y <= FARM_BOUNDS.yMax; y++) {
        for (let x = FARM_BOUNDS.xMin; x <= FARM_BOUNDS.xMax; x++) {
          world[y][x].type = TileType.FARM_GRASS;
        }
      }

      // Path between farm and town (slightly thick)
      for (let x = FARM_BOUNDS.xMax - 1; x <= TOWN_BOUNDS.xMin + 1; x++) {
        if (x < 0 || x >= WORLD_WIDTH) continue;
        for (let yOff = -1; yOff <= 1; yOff++) {
          const py = PATH_Y + yOff;
          if (py >= 0 && py < WORLD_HEIGHT) {
            world[py][x].type = TileType.PATH;
          }
        }
      }

      // Town stone cross (grey paths)
      for (let x = TOWN_BOUNDS.xMin; x <= TOWN_BOUNDS.xMax; x++) {
        if (TOWN_CENTER_Y >= TOWN_BOUNDS.yMin && TOWN_CENTER_Y <= TOWN_BOUNDS.yMax) {
          world[TOWN_CENTER_Y][x].type = TileType.TOWN_STONE;
        }
      }
      for (let y = TOWN_BOUNDS.yMin; y <= TOWN_BOUNDS.yMax; y++) {
        world[y][TOWN_CENTER_X].type = TileType.TOWN_STONE;
      }

      // ====== PLAYER & CAMERA ======
      const playerStartX =
        ((FARM_BOUNDS.xMin + FARM_BOUNDS.xMax) / 2) * TILE_SIZE + TILE_SIZE / 2;
      const playerStartY = PATH_Y * TILE_SIZE + TILE_SIZE / 2;

      const player = {
        x: playerStartX,
        y: playerStartY,
        width: 20,
        height: 24,
        speed: 140 // pixels per second
      };

      const camera = {
        x: 0,
        y: 0
      };

      // ====== NPC (merchant in town) ======
      const npc = {
        tileX: TOWN_CENTER_X,
        tileY: TOWN_CENTER_Y - 2 // just above the central cross
      };

      function isOnNPCTile(tileX, tileY) {
        return tileX === npc.tileX && tileY === npc.tileY;
      }

      // ====== INVENTORY ======
      const inventory = {
        seeds: 5,
        crops: 0,
        money: 0
      };

      function updateInventoryUI() {
        if (!inventoryDiv) return;
        inventoryDiv.innerHTML = `
          <ul class="inventory-list">
            <li>Seeds: ${inventory.seeds}</li>
            <li>Crops: ${inventory.crops}</li>
            <li>Money: ${inventory.money}g</li>
          </ul>
        `;
      }

      // ====== AUDIO ======
      // Put these files next to this HTML:
      //  - blip.wav        (small UI/text sound)
      //  - bgm_farm.mp3    (farm + path)
      //  - bgm_town.mp3    (town)
      const sounds = {
        blip: new Audio("blip.wav"),
        bgmFarm: new Audio("bgm_farm.mp3"),
        bgmTown: new Audio("bgm_town.mp3")
      };

      sounds.bgmFarm.loop = true;
      sounds.bgmTown.loop = true;

      let audioInitialized = false;
      let currentArea = null;
      let currentBGM = null;

      function getAreaForPosition(x, y) {
        const tileX = Math.floor(x / TILE_SIZE);
        const tileY = Math.floor(y / TILE_SIZE);

        if (
          tileX >= FARM_BOUNDS.xMin && tileX <= FARM_BOUNDS.xMax &&
          tileY >= FARM_BOUNDS.yMin && tileY <= FARM_BOUNDS.yMax
        ) {
          return "farm";
        }

        if (
          tileX >= TOWN_BOUNDS.xMin && tileX <= TOWN_BOUNDS.xMax &&
          tileY >= TOWN_BOUNDS.yMin && tileY <= TOWN_BOUNDS.yMax
        ) {
          return "town";
        }

        return "path";
      }

      function playBlip() {
        if (!audioInitialized) return;
        if (!sounds.blip) return;
        try {
          const blip = sounds.blip.cloneNode();
          blip.volume = 0.7;
          blip.play().catch(() => {});
        } catch (err) {
          // ignore audio errors
        }
      }

      function playBGMForArea(area) {
        // HUD area label
        if (areaNameSpan) {
          let label = "Farm";
          if (area === "town") label = "Town";
          else if (area === "path") label = "Path";
          areaNameSpan.textContent = label;
        }

        if (!audioInitialized) return;
        if (currentArea === area) return;

        currentArea = area;

        if (currentBGM) {
          currentBGM.pause();
          currentBGM.currentTime = 0;
        }

        let bgm = null;
        if (area === "farm" || area === "path") {
          bgm = sounds.bgmFarm;
        } else if (area === "town") {
          bgm = sounds.bgmTown;
        }

        currentBGM = bgm;
        if (currentBGM) {
          currentBGM.volume = 0.6;
          currentBGM.play().catch(() => {});
        }
      }

      function initAudio() {
        if (audioInitialized) return;
        audioInitialized = true;
        const area = getAreaForPosition(player.x, player.y);
        playBGMForArea(area);
      }

      // Start audio only after user interacts (browser autoplay rules)
      window.addEventListener("keydown", () => initAudio(), { once: true });
      window.addEventListener("mousedown", () => initAudio(), { once: true });

      // ====== CROPS ======
      function plantCrop(tile) {
        tile.crop = {
          age: 0,
          stage: 0
        };
      }

      function updateCrops(dt) {
        const perStage = CROP_GROWTH_TIME / (CROP_STAGES + 1);
        for (let y = 0; y < WORLD_HEIGHT; y++) {
          const row = world[y];
          for (let x = 0; x < WORLD_WIDTH; x++) {
            const tile = row[x];
            if (tile.crop) {
              tile.crop.age += dt;
              tile.crop.stage = Math.min(
                CROP_STAGES,
                Math.floor(tile.crop.age / perStage)
              );
            }
          }
        }
      }

      // ====== MESSAGES ======
      let currentMessage = "";
      let messageTimer = 0;
      const MESSAGE_DURATION = 2.0;

      function showMessage(text) {
        currentMessage = text;
        messageTimer = MESSAGE_DURATION;
        if (messageBox) {
          messageBox.textContent = text;
        }
        playBlip();
      }

      function updateMessages(dt) {
        if (messageTimer > 0) {
          messageTimer -= dt;
          if (messageTimer <= 0) {
            messageTimer = 0;
            currentMessage = "";
            if (messageBox) {
              messageBox.textContent = "";
            }
          }
        }
      }

      // ====== FARM / TILE HELPERS ======
      function isFarmTile(tileX, tileY) {
        if (
          tileX < FARM_BOUNDS.xMin || tileX > FARM_BOUNDS.xMax ||
          tileY < FARM_BOUNDS.yMin || tileY > FARM_BOUNDS.yMax
        ) {
          return false;
        }
        const tile = world[tileY][tileX];
        return (
          tile.type === TileType.FARM_GRASS ||
          tile.type === TileType.TILLED
        );
      }

      // ====== NPC INTERACTION ======
      function interactWithNPC() {
        const CROP_PRICE = 10;
        const SEED_PRICE = 5;

        if (inventory.crops > 0) {
          // Sell one crop
          inventory.crops -= 1;
          inventory.money += CROP_PRICE;
          updateInventoryUI();
          showMessage(`You sold 1 crop for ${CROP_PRICE}g.`);
        } else if (inventory.money >= SEED_PRICE) {
          // Buy one seed
          inventory.money -= SEED_PRICE;
          inventory.seeds += 1;
          updateInventoryUI();
          showMessage(`You bought 1 seed for ${SEED_PRICE}g.`);
        } else {
          showMessage("You need crops to sell or money to buy seeds.");
        }
      }

      // ====== INTERACTION (SPACEBAR) ======
      let wasSpaceDown = false;

      function handleActionInput() {
        const spaceDown = !!keys["Space"];
        if (spaceDown && !wasSpaceDown) {
          interactWithTile();
        }
        wasSpaceDown = spaceDown;
      }

      function interactWithTile() {
        const tileX = Math.floor(player.x / TILE_SIZE);
        const tileY = Math.floor(player.y / TILE_SIZE);

        if (tileX < 0 || tileX >= WORLD_WIDTH || tileY < 0 || tileY >= WORLD_HEIGHT) {
          return;
        }

        // First: check for NPC interaction
        if (isOnNPCTile(tileX, tileY)) {
          interactWithNPC();
          return;
        }

        const tile = world[tileY][tileX];

        // If not in farm area, you can't do farming actions
        if (!isFarmTile(tileX, tileY)) {
          showMessage("You can't farm here.");
          return;
        }

        // Farming actions
        if (tile.type === TileType.FARM_GRASS) {
          tile.type = TileType.TILLED;
          showMessage("You tilled the soil.");
        } else {
          if (!tile.crop && inventory.seeds > 0) {
            plantCrop(tile);
            inventory.seeds -= 1;
            updateInventoryUI();
            showMessage("You planted a seed.");
          } else if (tile.crop && tile.crop.stage >= CROP_STAGES) {
            tile.crop = null;
            inventory.crops += 1;
            updateInventoryUI();
            showMessage("You harvested a crop!");
          } else if (tile.crop) {
            showMessage("It's not ready yet...");
          } else {
            showMessage("You have no seeds.");
          }
        }
      }

      // ====== MOVEMENT ======
      function handleMovement(dt) {
        let dx = 0;
        let dy = 0;

        if (keys["ArrowUp"] || keys["KeyW"]) dy -= 1;
        if (keys["ArrowDown"] || keys["KeyS"]) dy += 1;
        if (keys["ArrowLeft"] || keys["KeyA"]) dx -= 1;
        if (keys["ArrowRight"] || keys["KeyD"]) dx += 1;

        if (dx !== 0 || dy !== 0) {
          const length = Math.hypot(dx, dy) || 1;
          dx /= length;
          dy /= length;

          player.x += dx * player.speed * dt;
          player.y += dy * player.speed * dt;

          const minX = TILE_SIZE / 2;
          const minY = TILE_SIZE / 2;
          const maxX = WORLD_WIDTH * TILE_SIZE - TILE_SIZE / 2;
          const maxY = WORLD_HEIGHT * TILE_SIZE - TILE_SIZE / 2;

          if (player.x < minX) player.x = minX;
          if (player.y < minY) player.y = minY;
          if (player.x > maxX) player.x = maxX;
          if (player.y > maxY) player.y = maxY;
        }
      }

      // ====== CAMERA ======
      function updateCamera() {
        camera.x = player.x - VIEWPORT_WIDTH / 2;
        camera.y = player.y - VIEWPORT_HEIGHT / 2;

        const maxCamX = WORLD_WIDTH * TILE_SIZE - VIEWPORT_WIDTH;
        const maxCamY = WORLD_HEIGHT * TILE_SIZE - VIEWPORT_HEIGHT;

        if (camera.x < 0) camera.x = 0;
        if (camera.y < 0) camera.y = 0;
        if (camera.x > maxCamX) camera.x = maxCamX;
        if (camera.y > maxCamY) camera.y = maxCamY;
      }

      // ====== DRAWING ======
      function draw() {
        // Clear
        ctx.fillStyle = "#1b1f2a";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const startTileX = Math.floor(camera.x / TILE_SIZE);
        const startTileY = Math.floor(camera.y / TILE_SIZE);
        const endTileX = Math.ceil((camera.x + VIEWPORT_WIDTH) / TILE_SIZE);
        const endTileY = Math.ceil((camera.y + VIEWPORT_HEIGHT) / TILE_SIZE);

        // Tiles + crops
        for (let y = startTileY; y < endTileY; y++) {
          if (y < 0 || y >= WORLD_HEIGHT) continue;
          for (let x = startTileX; x < endTileX; x++) {
            if (x < 0 || x >= WORLD_WIDTH) continue;

            const tile = world[y][x];
            const screenX = x * TILE_SIZE - camera.x;
            const screenY = y * TILE_SIZE - camera.y;

            // Base tile color
            if (tile.type === TileType.FARM_GRASS) {
              const noise = ((x * 13 + y * 7) % 10) - 5;
              const baseG = 125 + noise;
              ctx.fillStyle = `rgb(45, ${baseG}, 70)`;
            } else if (tile.type === TileType.TILLED) {
              ctx.fillStyle = "#6b4a2f";
            } else if (tile.type === TileType.PATH) {
              ctx.fillStyle = "#8b5a35"; // dirt path
            } else if (tile.type === TileType.TOWN_GRASS) {
              ctx.fillStyle = "#2a7f46"; // town-side green
            } else if (tile.type === TileType.TOWN_STONE) {
              ctx.fillStyle = "#7c828f"; // grey stone path
            } else {
              ctx.fillStyle = "#333"; // fallback
            }

            ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);

            // Tile border
            ctx.strokeStyle = "rgba(0,0,0,0.2)";
            ctx.strokeRect(screenX, screenY, TILE_SIZE, TILE_SIZE);

            // Crop
            if (tile.crop) {
              const stage = tile.crop.stage;
              let cropColor = "#3aa655";
              if (stage === 0) cropColor = "#3aa655";
              else if (stage === 1) cropColor = "#6cd96c";
              else if (stage >= CROP_STAGES) cropColor = "#f4e38b";

              const size = 10 + stage * 4;
              const cx = screenX + TILE_SIZE / 2 - size / 2;
              const cy = screenY + TILE_SIZE / 2 - size / 2;

              ctx.fillStyle = cropColor;
              ctx.fillRect(cx, cy, size, size);
              ctx.strokeStyle = "rgba(0,0,0,0.5)";
              ctx.strokeRect(cx, cy, size, size);
            }
          }
        }

        // NPC draw
        const npcScreenX = npc.tileX * TILE_SIZE - camera.x;
        const npcScreenY = npc.tileY * TILE_SIZE - camera.y;
        ctx.fillStyle = "#f2c089"; // body
        ctx.fillRect(
          npcScreenX + 8,
          npcScreenY + 6,
          TILE_SIZE - 16,
          TILE_SIZE - 12
        );
        ctx.fillStyle = "#5a3a2a"; // hair/hat
        ctx.fillRect(
          npcScreenX + 8,
          npcScreenY + 2,
          TILE_SIZE - 16,
          10
        );

        // Player
        const playerScreenX = player.x - camera.x;
        const playerScreenY = player.y - camera.y;

        ctx.fillStyle = "#f5d37b"; // body
        ctx.fillRect(
          playerScreenX - player.width / 2,
          playerScreenY - player.height / 2,
          player.width,
          player.height
        );

        ctx.fillStyle = "#3b2d2a"; // hair/hat
        ctx.fillRect(
          playerScreenX - player.width / 2,
          playerScreenY - player.height / 2,
          player.width,
          player.height / 3
        );

        // Highlight current tile under player
        const tileX = Math.floor(player.x / TILE_SIZE);
        const tileY = Math.floor(player.y / TILE_SIZE);
        const highlightX = tileX * TILE_SIZE - camera.x;
        const highlightY = tileY * TILE_SIZE - camera.y;
        ctx.strokeStyle = "rgba(255,255,255,0.6)";
        ctx.strokeRect(highlightX + 2, highlightY + 2, TILE_SIZE - 4, TILE_SIZE - 4);
      }

      // ====== MAIN UPDATE ======
      function update(dt) {
        handleMovement(dt);
        handleActionInput();
        updateCrops(dt);
        updateMessages(dt);
        updateCamera();

        const area = getAreaForPosition(player.x, player.y);
        playBGMForArea(area);
      }

      // ====== GAME LOOP ======
      let lastTime = 0;
      function gameLoop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        const dt = (timestamp - lastTime) / 1000;
        lastTime = timestamp;

        update(dt);
        draw();
        requestAnimationFrame(gameLoop);
      }

      // ====== INIT ======
      updateInventoryUI();
      showMessage("Farm on the left, town on the right. Follow the path and visit the merchant!");

      requestAnimationFrame(gameLoop);
    })();
  </script>
</body>
</html>
