<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mini Farm V3.1 (Hotbar System)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #11151c;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    #game {
      display: block;
      width: 100vw;
      height: 100vh;
      background: #000;
      image-rendering: pixelated;
    }

    .overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.6);
      z-index: 10;
    }

    .start-window {
      background: #181e2a;
      border-radius: 8px;
      border: 1px solid #272f42;
      padding: 16px 20px;
      min-width: 260px;
      max-width: 320px;
      box-shadow: 0 0 18px rgba(0, 0, 0, 0.7);
      color: #f1f1f1;
    }

    .start-window h1 {
      margin-top: 0;
      margin-bottom: 8px;
      font-size: 20px;
    }

    .menu-btn {
      width: 100%;
      padding: 8px 12px;
      margin-top: 8px;
      background: #242b3d;
      border-radius: 4px;
      border: 1px solid #3b4258;
      color: #f1f1f1;
      cursor: pointer;
      font-size: 13px;
    }

    .menu-btn:hover {
      background: #343c52;
    }

    .hidden {
      display: none !important;
    }

    /* Mobile controls */
    #mobile-controls {
      position: fixed;
      left: 16px;
      bottom: 16px;
      z-index: 9;
    }

    #mobile-dpad {
      display: grid;
      grid-template-columns: repeat(3, 48px);
      grid-template-rows: repeat(3, 48px);
      gap: 4px;
      justify-items: center;
      align-items: center;
    }

    .ctrl-btn {
      width: 48px;
      height: 48px;
      border-radius: 8px;
      background: #242b3d;
      border: 1px solid #3b4258;
      color: #f1f1f1;
      font-size: 20px;
      cursor: pointer;
    }

    .ctrl-btn:active {
      background: #3a435a;
    }

    .mobile-interact-btn {
      position: fixed;
      right: 16px;
      bottom: 32px;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: #2c7a4b;
      border: none;
      color: #f1f1f1;
      font-weight: bold;
      font-size: 13px;
      z-index: 9;
      box-shadow: 0 0 8px rgba(0, 0, 0, 0.6);
      cursor: pointer;
    }

    .mobile-interact-btn:active {
      background: #3d915f;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <!-- Start screen -->
  <div id="start-screen" class="overlay">
    <div class="start-window">
      <h1>Mini Farm</h1>
      <p style="font-size:13px;margin-bottom:4px;">
        Choose how you want to play:
      </p>
      <button id="choose-computer" class="menu-btn">Computer (Keyboard)</button>
      <button id="choose-mobile" class="menu-btn">Mobile (Touch)</button>
      <p style="font-size:11px;margin-top:10px;opacity:0.8;">
        Controls can be changed later by refreshing the page.
      </p>
    </div>
  </div>

  <!-- Mobile controls -->
  <div id="mobile-controls" class="hidden">
    <div id="mobile-dpad">
      <div></div>
      <button id="btn-up" class="ctrl-btn">▲</button>
      <div></div>
      <button id="btn-left" class="ctrl-btn">◀</button>
      <div></div>
      <button id="btn-right" class="ctrl-btn">▶</button>
      <div></div>
      <button id="btn-down" class="ctrl-btn">▼</button>
      <div></div>
    </div>
  </div>
  <button id="btn-interact" class="mobile-interact-btn hidden">Interact</button>

  <script>
    (() => {
      "use strict";

      // ============================================================
      //  CORE CONSTANTS
      // ============================================================
      const TILE_SIZE = 32;
      const WORLD_WIDTH = 64;
      const WORLD_HEIGHT = 40;

      const CROP_STAGES = 3;

      const FARM_BOUNDS = { xMin: 4, xMax: 28, yMin: 8, yMax: 32 };
      const TOWN_BOUNDS = { xMin: 38, xMax: 60, yMin: 8, yMax: 32 };
      const PATH_Y = Math.floor((FARM_BOUNDS.yMin + FARM_BOUNDS.yMax) / 2);
      const TOWN_CENTER_X = Math.floor((TOWN_BOUNDS.xMin + TOWN_BOUNDS.xMax) / 2);
      const TOWN_CENTER_Y = PATH_Y;

      const TEXTBOX_HEIGHT = 110;
      const HOTBAR_SLOT_WIDTH = 64;
      const HOTBAR_SLOT_HEIGHT = 64;
      const HOTBAR_SLOT_GAP = 8;
      const HOTBAR_SLOT_COUNT = 8; // more space to auto-add items

      // ============================================================
      //  CROP DEFINITIONS
      // ============================================================
      const cropTypes = [
        { id: "wheat",  name: "Wheat",  growthTime: 10, seedPrice: 5,  cropPrice: 10 },
        { id: "carrot", name: "Carrot", growthTime: 14, seedPrice: 8,  cropPrice: 16 },
        { id: "turnip", name: "Turnip", growthTime: 18, seedPrice: 12, cropPrice: 24 }
      ];
      const cropTypeById = {};
      cropTypes.forEach(t => cropTypeById[t.id] = t);

      const cropColors = {
        wheat:  ["#3aa655", "#c5c56e", "#f4e38b"],
        carrot: ["#2f864c", "#f49a3c", "#f4b23a"],
        turnip: ["#3c6b82", "#a78edb", "#f1d2ff"]
      };
      function getCropColor(cropId, stage) {
        const colors = cropColors[cropId] || ["#3aa655", "#6cd96c", "#f4e38b"];
        const idx = Math.max(0, Math.min(colors.length - 1, stage));
        return colors[idx];
      }

      // ============================================================
      //  DOM & CANVAS
      // ============================================================
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");

      const startScreen = document.getElementById("start-screen");
      const chooseComputerBtn = document.getElementById("choose-computer");
      const chooseMobileBtn = document.getElementById("choose-mobile");

      const mobileControls = document.getElementById("mobile-controls");
      const btnUp = document.getElementById("btn-up");
      const btnDown = document.getElementById("btn-down");
      const btnLeft = document.getElementById("btn-left");
      const btnRight = document.getElementById("btn-right");
      const interactButton = document.getElementById("btn-interact");

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      // ============================================================
      //  CONTROL MODE & MOBILE INPUT
      // ============================================================
      let controlMode = null; // "keyboard" | "mobile"
      const mobileInput = { up: false, down: false, left: false, right: false };
      let mobileInteractQueued = false;

      chooseComputerBtn.addEventListener("click", () => {
        controlMode = "keyboard";
        startScreen.classList.add("hidden");
      });
      chooseMobileBtn.addEventListener("click", () => {
        controlMode = "mobile";
        startScreen.classList.add("hidden");
        mobileControls.classList.remove("hidden");
        interactButton.classList.remove("hidden");
      });

      function setupMobileControls() {
        const attachDir = (btn, dir) => {
          if (!btn) return;
          const setDir = (value) => { mobileInput[dir] = value; };
          ["pointerdown", "mousedown", "touchstart"].forEach(ev => {
            btn.addEventListener(ev, (e) => {
              e.preventDefault();
              setDir(true);
            });
          });
          ["pointerup", "mouseleave", "touchend", "touchcancel", "pointercancel"].forEach(ev => {
            btn.addEventListener(ev, (e) => {
              e.preventDefault();
              setDir(false);
            });
          });
        };

        attachDir(btnUp, "up");
        attachDir(btnDown, "down");
        attachDir(btnLeft, "left");
        attachDir(btnRight, "right");

        if (interactButton) {
          ["click", "pointerdown", "touchstart"].forEach(ev => {
            interactButton.addEventListener(ev, (e) => {
              e.preventDefault();
              mobileInteractQueued = true;
            });
          });
        }
      }
      setupMobileControls();

      // ============================================================
      //  KEYBOARD INPUT
      // ============================================================
      const keys = {};
      window.addEventListener("keydown", (e) => {
        keys[e.code] = true;
        if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Space"].includes(e.code)) {
          e.preventDefault();
        }
        // Hotbar keys 1–8
        if (e.code.startsWith("Digit")) {
          const n = parseInt(e.code.slice(5), 10);
          if (n >= 1 && n <= HOTBAR_SLOT_COUNT) {
            selectHotbarSlot(n - 1);
          }
        }
      });
      window.addEventListener("keyup", (e) => {
        keys[e.code] = false;
      });

      // ============================================================
      //  POINTER INPUT (CLICK/TAP) – Hotbar, Dialogue, Shop
      // ============================================================
      function getCanvasPos(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {
          x: (clientX - rect.left) * scaleX,
          y: (clientY - rect.top) * scaleY
        };
      }

      function handlePointerDown(x, y) {
        // Dialogue click
        if (dialogue) {
          handleDialogueInteract();
          return;
        }
        // Shop click
        if (shopOpen) {
          handleShopClick(x, y);
          return;
        }
        // Hotbar click
        const slotIndex = hitTestHotbar(x, y);
        if (slotIndex !== -1) {
          selectHotbarSlot(slotIndex);
          return;
        }
      }

      canvas.addEventListener("mousedown", (e) => {
        const pos = getCanvasPos(e.clientX, e.clientY);
        handlePointerDown(pos.x, pos.y);
      });

      canvas.addEventListener("touchstart", (e) => {
        e.preventDefault();
        if (e.touches.length > 0) {
          const t = e.touches[0];
          const pos = getCanvasPos(t.clientX, t.clientY);
          handlePointerDown(pos.x, pos.y);
        }
      }, { passive: false });

      // ============================================================
      //  WORLD SETUP
      // ============================================================
      const TileType = {
        FARM_GRASS: 0,
        TILLED: 1,
        PATH: 2,
        TOWN_GRASS: 3,
        TOWN_STONE: 4
      };

      const world = [];
      for (let y = 0; y < WORLD_HEIGHT; y++) {
        const row = [];
        for (let x = 0; x < WORLD_WIDTH; x++) {
          row.push({
            type: TileType.TOWN_GRASS,
            crop: null // { age, stage, cropId }
          });
        }
        world.push(row);
      }

      // Farm area
      for (let y = FARM_BOUNDS.yMin; y <= FARM_BOUNDS.yMax; y++) {
        for (let x = FARM_BOUNDS.xMin; x <= FARM_BOUNDS.xMax; x++) {
          world[y][x].type = TileType.FARM_GRASS;
        }
      }

      // Path between farm and town
      for (let x = FARM_BOUNDS.xMax - 1; x <= TOWN_BOUNDS.xMin + 1; x++) {
        if (x < 0 || x >= WORLD_WIDTH) continue;
        for (let yOff = -1; yOff <= 1; yOff++) {
          const py = PATH_Y + yOff;
          if (py >= 0 && py < WORLD_HEIGHT) {
            world[py][x].type = TileType.PATH;
          }
        }
      }

      // Town stone cross
      for (let x = TOWN_BOUNDS.xMin; x <= TOWN_BOUNDS.xMax; x++) {
        if (TOWN_CENTER_Y >= TOWN_BOUNDS.yMin && TOWN_CENTER_Y <= TOWN_BOUNDS.yMax) {
          world[TOWN_CENTER_Y][x].type = TileType.TOWN_STONE;
        }
      }
      for (let y = TOWN_BOUNDS.yMin; y <= TOWN_BOUNDS.yMax; y++) {
        world[y][TOWN_CENTER_X].type = TileType.TOWN_STONE;
      }

      // ============================================================
      //  PLAYER & CAMERA
      // ============================================================
      const playerStartX = ((FARM_BOUNDS.xMin + FARM_BOUNDS.xMax) / 2) * TILE_SIZE + TILE_SIZE / 2;
      const playerStartY = PATH_Y * TILE_SIZE + TILE_SIZE / 2;

      const player = {
        x: playerStartX,
        y: playerStartY,
        width: 20,
        height: 24,
        speed: 140
      };

      const camera = { x: 0, y: 0 };

      // ============================================================
      //  NPC (Merchant)
      // ============================================================
      const npc = {
        tileX: TOWN_CENTER_X,
        tileY: TOWN_CENTER_Y - 2
      };
      function isOnNPCTile(tileX, tileY) {
        return tileX === npc.tileX && tileY === npc.tileY;
      }

      // ============================================================
      //  INVENTORY & HOTBAR SYSTEM (MODULAR)
      // ============================================================
      const inventory = {
        money: 0,
        seeds: {}, // { cropId: count }
        crops: {}  // { cropId: count }
      };

      // hotbar slots hold items or null
      // item = { category: "seed" | "crop", cropId: string }
      const hotbar = new Array(HOTBAR_SLOT_COUNT).fill(null);
      let hotbarRects = [];
      let selectedHotbarIndex = 0;

      const milestones = {
        firstPlant: false,
        firstHarvest: false,
        firstEnterTown: false
      };

      function isOnHotbar(category, cropId) {
        return hotbar.some(slot => slot && slot.category === category && slot.cropId === cropId);
      }

      function addToHotbar(category, cropId) {
        if (isOnHotbar(category, cropId)) return;
        const emptyIndex = hotbar.findIndex(slot => slot === null);
        if (emptyIndex !== -1) {
          hotbar[emptyIndex] = { category, cropId };
        }
      }

      function removeFromHotbarIfEmpty(category, cropId) {
        const store = category === "seed" ? inventory.seeds : inventory.crops;
        const count = store[cropId] || 0;
        if (count > 0) return;
        for (let i = 0; i < hotbar.length; i++) {
          const slot = hotbar[i];
          if (slot && slot.category === category && slot.cropId === cropId) {
            hotbar[i] = null;
          }
        }
      }

      function obtainItem(category, cropId, qty) {
        const store = category === "seed" ? inventory.seeds : inventory.crops;
        store[cropId] = (store[cropId] || 0) + qty;
        addToHotbar(category, cropId);
      }

      function modifyItem(category, cropId, delta) {
        const store = category === "seed" ? inventory.seeds : inventory.crops;
        const current = store[cropId] || 0;
        const next = Math.max(0, current + delta);
        store[cropId] = next;
        if (next === 0) {
          delete store[cropId];
          removeFromHotbarIfEmpty(category, cropId);
        }
      }

      function getActiveItem() {
        return hotbar[selectedHotbarIndex] || null;
      }

      function selectHotbarSlot(index) {
        if (index < 0 || index >= HOTBAR_SLOT_COUNT) return;
        selectedHotbarIndex = index;
        const slot = hotbar[index];
        if (!slot) {
          showTextBox(["Empty slot."]);
          return;
        }
        const type = cropTypeById[slot.cropId];
        if (!type) return;
        if (slot.category === "seed") {
          showTextBox(["Selected " + type.name + " seeds."]);
        } else {
          showTextBox(["Holding " + type.name + ". Sell these in town."]);
        }
      }

      function hitTestHotbar(x, y) {
        for (let i = 0; i < hotbarRects.length; i++) {
          const r = hotbarRects[i];
          if (!r) continue;
          if (x >= r.x && x <= r.x + r.w && y >= r.y && y <= r.y + r.h) {
            return i;
          }
        }
        return -1;
      }

      // Start inventory: give some wheat seeds via the same system
      obtainItem("seed", "wheat", 5);

      // ============================================================
      //  AUDIO
      // ============================================================
      const sounds = {
        blip: new Audio("blip.wav"),
        bgmFarm: new Audio("bgm_farm.mp3"),
        bgmTown: new Audio("bgm_town.mp3")
      };
      sounds.bgmFarm.loop = true;
      sounds.bgmTown.loop = true;

      let audioInitialized = false;
      let currentBgmArea = null;
      let hudArea = "farm";
      let lastArea = null;

      function getAreaForPosition(x, y) {
        const tileX = Math.floor(x / TILE_SIZE);
        const tileY = Math.floor(y / TILE_SIZE);
        if (tileX >= FARM_BOUNDS.xMin && tileX <= FARM_BOUNDS.xMax &&
            tileY >= FARM_BOUNDS.yMin && tileY <= FARM_BOUNDS.yMax) {
          return "farm";
        }
        if (tileX >= TOWN_BOUNDS.xMin && tileX <= TOWN_BOUNDS.xMax &&
            tileY >= TOWN_BOUNDS.yMin && tileY <= TOWN_BOUNDS.yMax) {
          return "town";
        }
        return "path";
      }

      function areaLabel(area) {
        if (area === "town") return "Town";
        if (area === "path") return "Path";
        return "Farm";
      }

      function playBlip() {
        if (!audioInitialized) return;
        if (!sounds.blip) return;
        try {
          const blip = sounds.blip.cloneNode();
          blip.volume = 0.7;
          blip.play().catch(() => {});
        } catch (err) {}
      }

      function playBgmForArea(area) {
        hudArea = area;
        if (!audioInitialized) return;
        if (currentBgmArea === area) return;
        currentBgmArea = area;

        if (sounds.bgmFarm) { sounds.bgmFarm.pause(); sounds.bgmFarm.currentTime = 0; }
        if (sounds.bgmTown) { sounds.bgmTown.pause(); sounds.bgmTown.currentTime = 0; }

        if (area === "farm" || area === "path") {
          sounds.bgmFarm.volume = 0.6;
          sounds.bgmFarm.play().catch(() => {});
        } else if (area === "town") {
          sounds.bgmTown.volume = 0.6;
          sounds.bgmTown.play().catch(() => {});
        }
      }

      function initAudio() {
        if (audioInitialized) return;
        audioInitialized = true;
        const area = getAreaForPosition(player.x, player.y);
        playBgmForArea(area);
      }

      window.addEventListener("keydown", () => initAudio(), { once: true });
      window.addEventListener("mousedown", () => initAudio(), { once: true });
      window.addEventListener("touchstart", () => initAudio(), { once: true });

      // ============================================================
      //  PLANTING / CROP SYSTEM
      // ============================================================
      function plantCrop(tile, cropId) {
        tile.crop = { age: 0, stage: 0, cropId };
      }

      function updateCrops(dt) {
        for (let y = 0; y < WORLD_HEIGHT; y++) {
          const row = world[y];
          for (let x = 0; x < WORLD_WIDTH; x++) {
            const tile = row[x];
            if (!tile.crop) continue;
            const type = cropTypeById[tile.crop.cropId];
            const growthTime = type ? type.growthTime : 12;
            const perStage = growthTime / (CROP_STAGES + 1);
            tile.crop.age += dt;
            tile.crop.stage = Math.min(
              CROP_STAGES,
              Math.floor(tile.crop.age / perStage)
            );
          }
        }
      }

      // ============================================================
      //  DIALOGUE / TEXTBOX (TYPEWRITER)
      // ============================================================
      let dialogue = null; // { lines, index, visibleChars, doneLine, time, speed, onComplete }

      function showTextBox(lines, options = {}) {
        dialogue = {
          lines: Array.isArray(lines) ? lines : [String(lines)],
          index: 0,
          visibleChars: 0,
          doneLine: false,
          time: 0,
          speed: options.speed || 50, // chars per second
          onComplete: options.onComplete || null
        };
      }

      function updateDialogue(dt) {
        if (!dialogue) return;
        const currentLine = dialogue.lines[dialogue.index];
        if (!dialogue.doneLine) {
          dialogue.time += dt;
          const targetChars = Math.floor(dialogue.time * dialogue.speed);
          const prevChars = dialogue.visibleChars;
          const newChars = Math.min(targetChars, currentLine.length);
          if (newChars > prevChars) {
            for (let i = prevChars; i < newChars; i++) {
              const ch = currentLine[i];
              if (ch && ch.trim() !== "") {
                playBlip();
              }
            }
            dialogue.visibleChars = newChars;
            if (dialogue.visibleChars >= currentLine.length) {
              dialogue.doneLine = true;
            }
          }
        }
      }

      function handleDialogueInteract() {
        if (!dialogue) return false;
        const currentLine = dialogue.lines[dialogue.index];
        if (!dialogue.doneLine) {
          dialogue.visibleChars = currentLine.length;
          dialogue.doneLine = true;
          return true;
        }
        if (dialogue.index < dialogue.lines.length - 1) {
          dialogue.index++;
          dialogue.visibleChars = 0;
          dialogue.doneLine = false;
          dialogue.time = 0;
          return true;
        }
        const cb = dialogue.onComplete;
        dialogue = null;
        if (typeof cb === "function") cb();
        return true;
      }

      // ============================================================
      //  SHOP SYSTEM
      // ============================================================
      let shopOpen = false;
      let shopButtons = []; // clickable regions this frame

      function openShop() {
        shopOpen = true;
      }
      function closeShop() {
        shopOpen = false;
      }

      function handleShopClick(x, y) {
        for (const btn of shopButtons) {
          if (x >= btn.x && x <= btn.x + btn.w &&
              y >= btn.y && y <= btn.y + btn.h) {
            shopButtonAction(btn);
            return;
          }
        }
      }

      function shopButtonAction(btn) {
        const type = cropTypeById[btn.cropId];
        if (!type) return;

        if (btn.action === "buy") {
          const price = type.seedPrice;
          if (inventory.money >= price) {
            inventory.money -= price;
            obtainItem("seed", type.id, 1);
            showTextBox(["Bought 1 " + type.name + " seed."]);
          } else {
            showTextBox(["Not enough money."]);
          }
        } else if (btn.action === "sell1") {
          const count = inventory.crops[type.id] || 0;
          if (count > 0) {
            modifyItem("crop", type.id, -1);
            inventory.money += type.cropPrice;
            showTextBox(["Sold 1 " + type.name + "."]);
          } else {
            showTextBox(["You have no " + type.name + " to sell."]);
          }
        } else if (btn.action === "sellAll") {
          const amount = inventory.crops[type.id] || 0;
          if (amount > 0) {
            modifyItem("crop", type.id, -amount);
            inventory.money += type.cropPrice * amount;
            showTextBox(["Sold " + amount + " " + type.name + "(s)."]);
          } else {
            showTextBox(["You have no " + type.name + " to sell."]);
          }
        }
      }

      // ============================================================
      //  FARM HELPERS
      // ============================================================
      function isFarmTile(tileX, tileY) {
        if (tileX < FARM_BOUNDS.xMin || tileX > FARM_BOUNDS.xMax ||
            tileY < FARM_BOUNDS.yMin || tileY > FARM_BOUNDS.yMax) {
          return false;
        }
        const tile = world[tileY][tileX];
        return (tile.type === TileType.FARM_GRASS || tile.type === TileType.TILLED);
      }

      // ============================================================
      //  INTERACTION (SPACE / MOBILE)
      // ============================================================
      let wasSpaceDown = false;

      function handleActionInput() {
        const spaceDown = !!keys["Space"];
        const keyboardTriggered = spaceDown && !wasSpaceDown;

        let mobileTriggered = false;
        if (controlMode === "mobile" && mobileInteractQueued) {
          mobileTriggered = true;
          mobileInteractQueued = false;
        }

        const triggered = keyboardTriggered || mobileTriggered;
        if (!triggered) {
          wasSpaceDown = spaceDown;
          return;
        }

        if (dialogue) {
          handleDialogueInteract();
          wasSpaceDown = spaceDown;
          return;
        }

        if (shopOpen) {
          closeShop();
          wasSpaceDown = spaceDown;
          return;
        }

        interactWithWorld();
        wasSpaceDown = spaceDown;
      }

      function interactWithWorld() {
        const tileX = Math.floor(player.x / TILE_SIZE);
        const tileY = Math.floor(player.y / TILE_SIZE);
        if (tileX < 0 || tileX >= WORLD_WIDTH || tileY < 0 || tileY >= WORLD_HEIGHT) return;

        // NPC interaction
        if (isOnNPCTile(tileX, tileY)) {
          showTextBox(
            [
              "Hey there! I buy crops and sell seeds.",
              "Grow good stuff and I'll make it worth your while."
            ],
            { onComplete: () => openShop() }
          );
          return;
        }

        const tile = world[tileY][tileX];

        // Only farm in farm area
        if (!isFarmTile(tileX, tileY)) {
          showTextBox(["You can't farm here."]);
          return;
        }

        const active = getActiveItem();
        if (!active || active.category !== "seed") {
          showTextBox(["Select seeds in your hotbar first."]);
          return;
        }

        const seedCropId = active.cropId;
        const seedType = cropTypeById[seedCropId];

        if (tile.type === TileType.FARM_GRASS) {
          tile.type = TileType.TILLED;
        } else {
          if (!tile.crop) {
            const seedCount = inventory.seeds[seedCropId] || 0;
            if (seedCount > 0) {
              plantCrop(tile, seedCropId);
              modifyItem("seed", seedCropId, -1);
              if (!milestones.firstPlant) {
                milestones.firstPlant = true;
                showTextBox([
                  "You planted your first " + seedType.name + "!",
                  "Now wait for it to grow before harvesting."
                ]);
              }
            } else {
              showTextBox(["You have no " + seedType.name + " seeds."]);
            }
          } else if (tile.crop && tile.crop.stage >= CROP_STAGES) {
            const harvestedId = tile.crop.cropId;
            const harvestedType = cropTypeById[harvestedId];
            tile.crop = null;
            obtainItem("crop", harvestedId, 1);
            if (!milestones.firstHarvest) {
              milestones.firstHarvest = true;
              showTextBox([
                "You harvested your first " + harvestedType.name + "!",
                "Take it to town and sell it to the merchant."
              ]);
            } else {
              showTextBox(["You harvested " + harvestedType.name + "."]);
            }
          } else if (tile.crop) {
            showTextBox(["It's not ready yet..."]);
          }
        }
      }

      // ============================================================
      //  MOVEMENT & CAMERA
      // ============================================================
      function handleMovement(dt) {
        let dx = 0;
        let dy = 0;

        const up = keys["ArrowUp"] || keys["KeyW"] || (controlMode === "mobile" && mobileInput.up);
        const down = keys["ArrowDown"] || keys["KeyS"] || (controlMode === "mobile" && mobileInput.down);
        const left = keys["ArrowLeft"] || keys["KeyA"] || (controlMode === "mobile" && mobileInput.left);
        const right = keys["ArrowRight"] || keys["KeyD"] || (controlMode === "mobile" && mobileInput.right);

        if (up) dy -= 1;
        if (down) dy += 1;
        if (left) dx -= 1;
        if (right) dx += 1;

        if (dx !== 0 || dy !== 0) {
          const len = Math.hypot(dx, dy) || 1;
          dx /= len;
          dy /= len;

          player.x += dx * player.speed * dt;
          player.y += dy * player.speed * dt;

          const minX = TILE_SIZE / 2;
          const minY = TILE_SIZE / 2;
          const maxX = WORLD_WIDTH * TILE_SIZE - TILE_SIZE / 2;
          const maxY = WORLD_HEIGHT * TILE_SIZE - TILE_SIZE / 2;

          if (player.x < minX) player.x = minX;
          if (player.y < minY) player.y = minY;
          if (player.x > maxX) player.x = maxX;
          if (player.y > maxY) player.y = maxY;
        }
      }

      function updateCamera() {
        const vw = canvas.width;
        const vh = canvas.height;
        camera.x = player.x - vw / 2;
        camera.y = player.y - vh / 2;

        const maxCamX = WORLD_WIDTH * TILE_SIZE - vw;
        const maxCamY = WORLD_HEIGHT * TILE_SIZE - vh;

        if (camera.x < 0) camera.x = 0;
        if (camera.y < 0) camera.y = 0;
        if (camera.x > maxCamX) camera.x = maxCamX;
        if (camera.y > maxCamY) camera.y = maxCamY;
      }

      // ============================================================
      //  RENDERING
      // ============================================================
      function drawWorld() {
        const vw = canvas.width;
        const vh = canvas.height;

        ctx.fillStyle = "#1b1f2a";
        ctx.fillRect(0, 0, vw, vh);

        const startTileX = Math.floor(camera.x / TILE_SIZE);
        const startTileY = Math.floor(camera.y / TILE_SIZE);
        const endTileX = Math.ceil((camera.x + vw) / TILE_SIZE);
        const endTileY = Math.ceil((camera.y + vh) / TILE_SIZE);

        for (let y = startTileY; y < endTileY; y++) {
          if (y < 0 || y >= WORLD_HEIGHT) continue;
          for (let x = startTileX; x < endTileX; x++) {
            if (x < 0 || x >= WORLD_WIDTH) continue;

            const tile = world[y][x];
            const screenX = x * TILE_SIZE - camera.x;
            const screenY = y * TILE_SIZE - camera.y;

            if (tile.type === TileType.FARM_GRASS) {
              const noise = ((x * 13 + y * 7) % 10) - 5;
              const baseG = 125 + noise;
              ctx.fillStyle = `rgb(45, ${baseG}, 70)`;
            } else if (tile.type === TileType.TILLED) {
              ctx.fillStyle = "#6b4a2f";
            } else if (tile.type === TileType.PATH) {
              ctx.fillStyle = "#8b5a35";
            } else if (tile.type === TileType.TOWN_GRASS) {
              ctx.fillStyle = "#2a7f46";
            } else if (tile.type === TileType.TOWN_STONE) {
              ctx.fillStyle = "#7c828f";
            } else {
              ctx.fillStyle = "#333";
            }

            ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
            ctx.strokeStyle = "rgba(0,0,0,0.2)";
            ctx.strokeRect(screenX, screenY, TILE_SIZE, TILE_SIZE);

            if (tile.crop) {
              const stage = tile.crop.stage;
              const color = getCropColor(tile.crop.cropId, stage);
              const size = 10 + stage * 4;
              const cx = screenX + TILE_SIZE / 2 - size / 2;
              const cy = screenY + TILE_SIZE / 2 - size / 2;
              ctx.fillStyle = color;
              ctx.fillRect(cx, cy, size, size);
              ctx.strokeStyle = "rgba(0,0,0,0.5)";
              ctx.strokeRect(cx, cy, size, size);
            }
          }
        }
      }

      function drawNPC() {
        const screenX = npc.tileX * TILE_SIZE - camera.x;
        const screenY = npc.tileY * TILE_SIZE - camera.y;
        ctx.fillStyle = "#f2c089";
        ctx.fillRect(screenX + 8, screenY + 6, TILE_SIZE - 16, TILE_SIZE - 12);
        ctx.fillStyle = "#5a3a2a";
        ctx.fillRect(screenX + 8, screenY + 2, TILE_SIZE - 16, 10);
      }

      function drawPlayer() {
        const screenX = player.x - camera.x;
        const screenY = player.y - camera.y;
        ctx.fillStyle = "#f5d37b";
        ctx.fillRect(
          screenX - player.width / 2,
          screenY - player.height / 2,
          player.width,
          player.height
        );
        ctx.fillStyle = "#3b2d2a";
        ctx.fillRect(
          screenX - player.width / 2,
          screenY - player.height / 2,
          player.width,
          player.height / 3
        );

        const tileX = Math.floor(player.x / TILE_SIZE);
        const tileY = Math.floor(player.y / TILE_SIZE);
        const highlightX = tileX * TILE_SIZE - camera.x;
        const highlightY = tileY * TILE_SIZE - camera.y;
        ctx.strokeStyle = "rgba(255,255,255,0.6)";
        ctx.strokeRect(highlightX + 2, highlightY + 2, TILE_SIZE - 4, TILE_SIZE - 4);
      }

      function drawHUD() {
        const vw = canvas.width;
        const vh = canvas.height;

        // Area + money
        const boxW = 160;
        const boxH = 52;
        const pad = 12;
        ctx.fillStyle = "rgba(0,0,0,0.55)";
        ctx.fillRect(pad, pad, boxW, boxH);
        ctx.strokeStyle = "rgba(255,255,255,0.4)";
        ctx.strokeRect(pad, pad, boxW, boxH);

        ctx.fillStyle = "#f1f1f1";
        ctx.font = "14px sans-serif";
        ctx.fillText("Area: " + areaLabel(hudArea), pad + 8, pad + 20);
        ctx.fillText("Money: " + inventory.money + "g", pad + 8, pad + 38);

        // Hotbar
        hotbarRects = [];
        const totalWidth = HOTBAR_SLOT_COUNT * HOTBAR_SLOT_WIDTH +
                           (HOTBAR_SLOT_COUNT - 1) * HOTBAR_SLOT_GAP;
        const startX = (vw - totalWidth) / 2;
        const y = vh - HOTBAR_SLOT_HEIGHT - 16;

        for (let i = 0; i < HOTBAR_SLOT_COUNT; i++) {
          const slotItem = hotbar[i];
          const x = startX + i * (HOTBAR_SLOT_WIDTH + HOTBAR_SLOT_GAP);
          const r = { x, y, w: HOTBAR_SLOT_WIDTH, h: HOTBAR_SLOT_HEIGHT };
          hotbarRects.push(r);

          ctx.fillStyle = "rgba(0,0,0,0.7)";
          ctx.fillRect(x, y, HOTBAR_SLOT_WIDTH, HOTBAR_SLOT_HEIGHT);
          ctx.strokeStyle = i === selectedHotbarIndex ? "#f4e38b" : "rgba(255,255,255,0.4)";
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, HOTBAR_SLOT_WIDTH, HOTBAR_SLOT_HEIGHT);
          ctx.lineWidth = 1;

          ctx.fillStyle = "rgba(255,255,255,0.7)";
          ctx.font = "10px sans-serif";
          ctx.fillText(String(i + 1), x + 6, y + 14);

          if (!slotItem) continue;

          const type = cropTypeById[slotItem.cropId];
          const baseColor = getCropColor(slotItem.cropId, 0);

          ctx.fillStyle = baseColor;
          ctx.fillRect(x + 10, y + 14, 24, 24);
          ctx.strokeStyle = "rgba(0,0,0,0.6)";
          ctx.strokeRect(x + 10, y + 14, 24, 24);

          ctx.fillStyle = "#f1f1f1";
          ctx.font = "11px sans-serif";
          const label = type ? type.name[0] : "?";
          ctx.fillText(label, x + 18, y + 30);

          ctx.fillStyle = "rgba(220,220,220,0.8)";
          ctx.font = "10px sans-serif";
          ctx.fillText(
            slotItem.category === "seed" ? "Seed" : "Crop",
            x + 8,
            y + 50
          );

          const qty = slotItem.category === "seed"
            ? (inventory.seeds[slotItem.cropId] || 0)
            : (inventory.crops[slotItem.cropId] || 0);
          ctx.fillStyle = "#ffffff";
          ctx.font = "11px sans-serif";
          ctx.textAlign = "right";
          ctx.fillText(String(qty), x + HOTBAR_SLOT_WIDTH - 6, y + HOTBAR_SLOT_HEIGHT - 8);
          ctx.textAlign = "left";
        }

        // Controls hint
        ctx.fillStyle = "rgba(0,0,0,0.45)";
        const hintW = 190;
        const hintH = 40;
        const hx = vw - hintW - pad;
        const hy = pad;
        ctx.fillRect(hx, hy, hintW, hintH);
        ctx.strokeStyle = "rgba(255,255,255,0.25)";
        ctx.strokeRect(hx, hy, hintW, hintH);
        ctx.fillStyle = "#c5cde0";
        ctx.font = "11px sans-serif";
        ctx.fillText("Move: WASD / Arrows", hx + 8, hy + 16);
        ctx.fillText("Interact: Space / Button", hx + 8, hy + 30);
      }

      function drawDialogueBox() {
        if (!dialogue) return;
        const vw = canvas.width;
        const vh = canvas.height;

        const boxW = vw - 40;
        const boxH = TEXTBOX_HEIGHT;
        const x = 20;
        const y = vh - boxH - 20;

        ctx.fillStyle = "rgba(0,0,0,0.8)";
        ctx.fillRect(x, y, boxW, boxH);
        ctx.strokeStyle = "rgba(255,255,255,0.6)";
        ctx.strokeRect(x, y, boxW, boxH);

        const currentLine = dialogue.lines[dialogue.index];
        const text = currentLine.slice(0, dialogue.visibleChars);

        ctx.fillStyle = "#f1f1f1";
        ctx.font = "14px sans-serif";
        const textX = x + 16;
        let textY = y + 26;

        const words = text.split(" ");
        let line = "";
        const maxWidth = boxW - 32;
        for (let i = 0; i < words.length; i++) {
          const testLine = line + (line ? " " : "") + words[i];
          const metrics = ctx.measureText(testLine);
          if (metrics.width > maxWidth && line) {
            ctx.fillText(line, textX, textY);
            line = words[i];
            textY += 18;
          } else {
            line = testLine;
          }
        }
        if (line) {
          ctx.fillText(line, textX, textY);
        }

        if (dialogue.doneLine) {
          const arrowX = x + boxW - 26;
          const arrowY = y + boxH - 16;
          ctx.font = "16px sans-serif";
          ctx.fillStyle = "#f4e38b";
          ctx.fillText("▼", arrowX, arrowY);
        }
      }

      function drawShopPanel() {
        if (!shopOpen) return;
        const vw = canvas.width;
        const vh = canvas.height;

        shopButtons = [];

        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(0, 0, vw, vh);

        const panelW = 420;
        const panelH = 260;
        const x = (vw - panelW) / 2;
        const y = (vh - panelH) / 2;

        ctx.fillStyle = "#181e2a";
        ctx.fillRect(x, y, panelW, panelH);
        ctx.strokeStyle = "rgba(255,255,255,0.7)";
        ctx.strokeRect(x, y, panelW, panelH);

        ctx.fillStyle = "#f1f1f1";
        ctx.font = "18px sans-serif";
        ctx.fillText("Merchant", x + 16, y + 26);

        ctx.font = "12px sans-serif";
        ctx.fillStyle = "#c5cde0";
        ctx.fillText("Click buttons to buy/sell. Interact closes shop.", x + 16, y + 44);

        // Seeds
        ctx.fillStyle = "#101521";
        ctx.fillRect(x + 12, y + 56, panelW - 24, 90);
        ctx.strokeStyle = "rgba(255,255,255,0.15)";
        ctx.strokeRect(x + 12, y + 56, panelW - 24, 90);
        ctx.fillStyle = "#f1f1f1";
        ctx.font = "13px sans-serif";
        ctx.fillText("Buy Seeds", x + 20, y + 72);

        let bx = x + 20;
        let by = y + 82;
        const itemBoxW = 120;
        const itemBoxH = 54;

        for (const t of cropTypes) {
          ctx.fillStyle = "#181e2a";
          ctx.fillRect(bx, by, itemBoxW, itemBoxH);
          ctx.strokeStyle = "rgba(255,255,255,0.2)";
          ctx.strokeRect(bx, by, itemBoxW, itemBoxH);

          const iconColor = getCropColor(t.id, 0);
          ctx.fillStyle = iconColor;
          ctx.fillRect(bx + 8, by + 12, 20, 20);
          ctx.strokeStyle = "rgba(0,0,0,0.6)";
          ctx.strokeRect(bx + 8, by + 12, 20, 20);

          ctx.fillStyle = "#f1f1f1";
          ctx.font = "12px sans-serif";
          ctx.fillText(t.name + " Seed", bx + 32, by + 20);
          ctx.fillStyle = "#c5cde0";
          ctx.font = "11px sans-serif";
          ctx.fillText(t.seedPrice + "g", bx + 32, by + 34);

          const btnW = 46;
          const btnH = 20;
          const btnX = bx + itemBoxW - btnW - 6;
          const btnY = by + itemBoxH - btnH - 6;
          ctx.fillStyle = "#2c7a4b";
          ctx.fillRect(btnX, btnY, btnW, btnH);
          ctx.strokeStyle = "#1f5835";
          ctx.strokeRect(btnX, btnY, btnW, btnH);
          ctx.fillStyle = "#f1f1f1";
          ctx.font = "11px sans-serif";
          ctx.fillText("Buy", btnX + 11, btnY + 14);

          shopButtons.push({
            action: "buy",
            cropId: t.id,
            x: btnX,
            y: btnY,
            w: btnW,
            h: btnH
          });

          bx += itemBoxW + 10;
        }

        // Crops
        const sellTop = y + 56 + 90 + 8;
        ctx.fillStyle = "#101521";
        ctx.fillRect(x + 12, sellTop, panelW - 24, 90);
        ctx.strokeStyle = "rgba(255,255,255,0.15)";
        ctx.strokeRect(x + 12, sellTop, panelW - 24, 90);
        ctx.fillStyle = "#f1f1f1";
        ctx.font = "13px sans-serif";
        ctx.fillText("Sell Crops", x + 20, sellTop + 16);

        bx = x + 20;
        by = sellTop + 24;

        for (const t of cropTypes) {
          ctx.fillStyle = "#181e2a";
          ctx.fillRect(bx, by, itemBoxW, itemBoxH);
          ctx.strokeStyle = "rgba(255,255,255,0.2)";
          ctx.strokeRect(bx, by, itemBoxW, itemBoxH);

          const iconColor = getCropColor(t.id, 2);
          ctx.fillStyle = iconColor;
          ctx.fillRect(bx + 8, by + 12, 20, 20);
          ctx.strokeStyle = "rgba(0,0,0,0.6)";
          ctx.strokeRect(bx + 8, by + 12, 20, 20);

          ctx.fillStyle = "#f1f1f1";
          ctx.font = "12px sans-serif";
          ctx.fillText(t.name, bx + 32, by + 20);
          ctx.fillStyle = "#c5cde0";
          ctx.font = "11px sans-serif";
          ctx.fillText(t.cropPrice + "g each", bx + 32, by + 34);

          const btnW = 46;
          const btnH = 20;
          const btnX1 = bx + itemBoxW - btnW - 6;
          const btnY1 = by + 4;
          ctx.fillStyle = "#7a2c2c";
          ctx.fillRect(btnX1, btnY1, btnW, btnH);
          ctx.strokeStyle = "#5a1f1f";
          ctx.strokeRect(btnX1, btnY1, btnW, btnH);
          ctx.fillStyle = "#f1f1f1";
          ctx.font = "10px sans-serif";
          ctx.fillText("Sell 1", btnX1 + 7, btnY1 + 13);

          shopButtons.push({
            action: "sell1",
            cropId: t.id,
            x: btnX1,
            y: btnY1,
            w: btnW,
            h: btnH
          });

          const btnX2 = bx + itemBoxW - btnW - 6;
          const btnY2 = by + itemBoxH - btnH - 6;
          ctx.fillStyle = "#a33d3d";
          ctx.fillRect(btnX2, btnY2, btnW, btnH);
          ctx.strokeStyle = "#702929";
          ctx.strokeRect(btnX2, btnY2, btnW, btnH);
          ctx.fillStyle = "#f1f1f1";
          ctx.font = "10px sans-serif";
          ctx.fillText("All", btnX2 + 14, btnY2 + 13);

          shopButtons.push({
            action: "sellAll",
            cropId: t.id,
            x: btnX2,
            y: btnY2,
            w: btnW,
            h: btnH
          });

          bx += itemBoxW + 10;
        }
      }

      function draw() {
        drawWorld();
        drawNPC();
        drawPlayer();
        drawHUD();
        if (shopOpen) drawShopPanel();
        drawDialogueBox();
      }

      // ============================================================
      //  MAIN UPDATE LOOP
      // ============================================================
      function update(dt) {
        if (!shopOpen && !dialogue) {
          handleMovement(dt);
        }
        handleActionInput();
        updateCrops(dt);
        updateDialogue(dt);
        updateCamera();

        const area = getAreaForPosition(player.x, player.y);
        playBgmForArea(area);

        if (area !== lastArea) {
          if (area === "town" && !milestones.firstEnterTown) {
            milestones.firstEnterTown = true;
            showTextBox([
              "You arrive at a small town.",
              "Maybe someone here buys crops..."
            ]);
          }
          lastArea = area;
        }
      }

      let lastTime = 0;
      function gameLoop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        const dt = (timestamp - lastTime) / 1000;
        lastTime = timestamp;

        update(dt);
        draw();
        requestAnimationFrame(gameLoop);
      }

      // ============================================================
      //  INIT
      // ============================================================
      showTextBox([
        "Farm on the left, town on the right.",
        "Plant seeds, harvest crops, and trade with the merchant."
      ]);

      requestAnimationFrame(gameLoop);
    })();
  </script>
</body>
</html>
